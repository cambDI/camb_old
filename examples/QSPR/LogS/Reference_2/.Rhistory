?train
library(caret)
?train
setwd("~/Dropbox/projects/camb/examples/QSPR/LogS/Reference_2")
library(camb)
StandardiseMolecules(structures.file="solubility_2007_ref2.sdf",
standardised.file="standardised.sdf",
removed.file="removed.sdf",
properties.file = "properties.csv",
remove.inorganic=TRUE,
fluorine.limit=3,
chlorine.limit=3,
bromine.limit=3,
iodine.limit=3,
min.mass.limit=20,
max.mass.limit=900)
properties <- read.table("properties.csv", header=TRUE, sep="\t")
properties <- properties[properties$Kept==1, ]
head(properties)
targets <- data.frame(Name = properties$NAME, target = properties$EXPT)
p <- DensityResponse(targets$target) + xlab("LogS Target Distribution")
p
descriptors <- readRDS("descriptors.rds")
all <- merge(x=targets, y=descriptors, by="Name")
ids <- all$Name
x <- all[3:ncol(all)]
y <- all$target
x.finite <- ReplaceInfinitesWithNA(x)
x.imputed <- ImputeFeatures(x.finite)
detach("package:camb", unload=TRUE)
library("camb", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
x.finite <- ReplaceInfinitesWithNA(x)
x.imputed <- ImputeFeatures(x.finite)
library(devtools)
setwd("~/Dropbox/projects/camb/roxygen")
document('../camb')
setwd("~/Dropbox/projects/camb/examples/QSPR/LogS/Reference_2")
x.finite <- ReplaceInfinitesWithNA(x)
x.imputed <- ImputeFeatures(x.finite)
ImputeFeatures <- function(d, k=10,...) {
suppressWarnings(require(impute)) || stop("Package impute is required. Install from CRAN or Bioconductor -depending on the R version you are using-.")
as.data.frame(impute.knn(as.matrix(d), k = k, ...)$data)
}
x.imputed <- ImputeFeatures(x.finite)
summary(x.finite)
ImputeFeatures <- function(d, k=10,...) {
suppressWarnings(require(impute)) || stop("Package impute is required. Install from CRAN or Bioconductor -depending on the R version you are using-.")
as.data.frame(impute.knn(as.matrix(factorsNumeric(d)), k = k, ...)$data)
}
x.imputed <- ImputeFeatures(x.finite)
asNumeric <- function(x) as.numeric(as.character(x))
factorsNumeric <- function(d) modifyList(d, lapply(d[, sapply(d, is.factor)],
asNumeric))
x.imputed <- ImputeFeatures(x.finite)
dataset <- SplitSet(ids, x.imputed, y, percentage=20)
dataset <- RemoveNearZeroVarianceFeatures(dataset, frequencyCutoff=30)
dataset <- RemoveHighlyCorrelatedFeatures(dataset, correlationCutoff=0.95)
dataset <- PreProcess(dataset)
dataset <- GetCVTrainControl(dataset)
saveRDS(dataset, file="dataset.rds")
registerDoMC(cores=1)
library(doMC)
registerDoMC(cores=1)
method <- "svmRadial"
tune.grid <- expand.grid(.sigma = expGrid(-8, 4, 2, 2), .C = c(0.0001, 0.001, 0.01, 0.1, 1, 10, 100))
model <- train(dataset$x.train, dataset$y.train, method, tuneGrid=tune.grid, trControl=dataset$trControl)
saveRDS(model, file=paste(method,".rds",sep=""))
model <- readRDS("svmRadial.rds")
plot(model, metric = "RMSE")
method <- "rf"
tune.grid <- expand.grid(.mtry = seq(5,100,5))
model <- train(dataset$x.train, dataset$y.train, method, tuneGrid=tune.grid, trControl=dataset$trControl)
method <- "gbm"
tune.grid <- expand.grid(.n.trees=c(500,1000), .interaction.depth=c(25), .shrinkage = c(0.04, 0.08, 0.16))
model <- train(dataset$x.train, dataset$y.train, method, tuneGrid=tune.grid, trControl=dataset$trControl)
saveRDS(model, file=paste(method,".rds",sep=""))
plot(model, metric = "RMSE")
model <- readRDS("rf.rds")
plot(model, metric = "RMSE")
model <- readRDS("rf.rds")
plot(model, metric = "RMSE")
method <- "rf"
tune.grid <- expand.grid(.mtry = seq(5,100,5))
model <- train(dataset$x.train, dataset$y.train, method, tuneGrid=tune.grid, trControl=dataset$trControl)
saveRDS(model, file=paste(method,".rds",sep=""))
plot(model, metric = "RMSE")
setwd("~/Dropbox/projects/camb/examples/QSPR/LogS/Reference_2")
model <- readRDS("svmRadial.rds")
plot(model, metric = "RMSE")
model <- readRDS("rf.rds")
plot(model, metric = "RMSE")
model <- readRDS("gbm.rds")
plot(model, metric = "RMSE")
method <- "gbm"
tune.grid <- expand.grid(.n.trees=c(500,1000), .interaction.depth=c(25), .shrinkage = c(0.04, 0.08, 0.16))
method <- "gbm"
tune.grid <- expand.grid(.n.trees=c(500,1000), .interaction.depth=c(25), .shrinkage = c(0.01, 0.02, 0.04, 0.08))
model <- train(dataset$x.train, dataset$y.train, method, tuneGrid=tune.grid, trControl=dataset$trControl)
saveRDS(model, file=paste(method,".rds",sep=""))
library(caret)
method <- "gbm"
tune.grid <- expand.grid(.n.trees=c(500,1000), .interaction.depth=c(25), .shrinkage = c(0.01, 0.02, 0.04, 0.08))
model <- train(dataset$x.train, dataset$y.train, method, tuneGrid=tune.grid, trControl=dataset$trControl)
plot(model, metric = "RMSE")
saveRDS(model, file=paste(method,".rds",sep=""))
model <- readRDS("gbm.rds")
plot(model, metric = "RMSE")
model <- readRDS("rf.rds")
plot(model, metric = "RMSE")
library(camb)
setwd('~/Dropbox/projects/camb/examples/QSPR/LogS/Reference_2')
StandardiseMolecules(structures.file="solubility_2007_ref2.sdf",
standardised.file="standardised.sdf",
removed.file="removed.sdf",
properties.file = "properties.csv",
remove.inorganic=TRUE,
fluorine.limit=3,
chlorine.limit=3,
bromine.limit=3,
iodine.limit=3,
min.mass.limit=20,
max.mass.limit=900)
setwd("~/Dropbox/projects/camb/examples/QSPR/LogS/Reference_2")
library("camb", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
library(devtools)
setwd("~/Dropbox/projects/camb/roxygen")
document('../camb')
setwd("~/Dropbox/projects/camb/examples/QSPR/LogS/Reference_2")
library("camb", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
all.models <- list()
all.models[[length(all.models)+1]] <- readRDS("gbm.rds")
all.models[[length(all.models)+1]] <- readRDS("svmRadial.rds")
all.models[[length(all.models)+1]] <- readRDS("rf.rds")
names(all.models) <- sapply(all.models, function(x) x$method)
sort(sapply(all.models, function(x) min(as.vector(na.omit(x$results$RMSE)))))
greedy <- caretEnsemble(all.models, iter=1000L)
sort(greedy$weights, decreasing=TRUE)
greedy$error
save(greedy, file="greedy.rds")
CorrelationPlot(pred=holdout.predictions,obs=dataset$y.holdout,PointSize=3,ColMargin='blue',TitleSize=26,XAxisSize=20,YAxisSize=20,TitleAxesSize=24,margin=2,PointColor="black",PointShape=16,MarginWidth=1,AngleLab=0,xlab="Observed",ylab="Predicted")
holdout.predictions <- as.vector(predict(modelCoxRF$finalModel, newdata = dataset$x.holdout))
holdout.predictions <- as.vector(predict(model, newdata = dataset$x.holdout))
holdout.predictions <- as.vector(predict(model$finalModel, newdata = dataset$x.holdout))
model <- readRDS("rf.rds")
holdout.predictions <- as.vector(predict(model$finalModel, newdata = dataset$x.holdout))
holdout.predictions <- as.vector(predict(model, newdata = dataset$x.holdout))
holdout.predictions <- as.vector(predict(model$finalModel, newdata = dataset$x.holdout))
model
dataset
holdout.predictions <- as.vector(predict(model$finalModel, newdata = dataset$x.holdout))
detach("package:caret", unload=TRUE)
library("caret", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
holdout.predictions <- as.vector(predict(model$finalModel, newdata = dataset$x.holdout))
library(randomForest)
holdout.predictions <- as.vector(predict(model$finalModel, newdata = dataset$x.holdout))
CorrelationPlot(pred=holdout.predictions,obs=dataset$y.holdout,PointSize=3,ColMargin='blue',TitleSize=26,XAxisSize=20,YAxisSize=20,TitleAxesSize=24,margin=2,PointColor="black",PointShape=16,MarginWidth=1,AngleLab=0,xlab="Observed",ylab="Predicted")
linear <- caretStack(all.models, method='glm', trControl=trainControl(method='cv'))
summary(linear$ens_model$finalModel)
saveRDS(greedy, file="greedy.rds")
saveRDS(linear, file="linear.rds")
tune.grid <- expand.grid(.mtry = seq(1,length(all.models),1))
nonlinear <- caretStack(all.models, method='rf', trControl=trainControl(method='cv'), tune.grid=tune.grid)
nonlinear$error
nonlinear$error
nonlinear <- caretStack(all.models, method='rf', trControl=trainControl(method='cv'), tune.grid=tune.grid)
saveRDS(nonlinear, file="nonlinear.rds")
preds <- data.frame(sapply(all.models, predict, newdata=x.test))
preds <- data.frame(sapply(all.models, predict, newdata=dataset$x.test))
preds <- data.frame(sapply(all.models, predict, newdata=dataset$x.holdout))
preds
preds$ENS_greedy <- predict(greedy, newdata=dataset$x.holdout)
preds$ENS_linear <- predict(linear, newdata=dataset$x.holdout)
preds$ENS_nonlinear <- predict(nonlinear, newdata=dataset$x.holdout)
sort(sqrt(colMeans((preds - y.test) ^ 2)))
sort(sqrt(colMeans((preds - dataset$y.holdout) ^ 2)))
greedy$error
sort(sapply(all.models, function(x) min(as.vector(na.omit(x$results$RMSE)))))
all.models[[length(all.models)+1]] <- greedy
sort(sapply(all.models, function(x) min(as.vector(na.omit(x$results$RMSE)))))
greedy
model <- readRDS("rf.rds")
model$error
sapply(all.models, function(x) x$error <- min(as.vector(na.omit(x$results$RMSE))))
all.models <- list()
all.models[[length(all.models)+1]] <- readRDS("gbm.rds")
all.models[[length(all.models)+1]] <- readRDS("svmRadial.rds")
all.models[[length(all.models)+1]] <- readRDS("rf.rds")
sapply(all.models, function(x) x$error <- min(as.vector(na.omit(x$results$RMSE))))
all.models[[1]]$error
for i in 1:length(all.models) {
all.models[[i]]$error <- min(as.vector(na.omit(all.models[[i]]$results$RMSE)))
}
for (i in 1:length(all.models)) {
all.models[[i]]$error <- min(as.vector(na.omit(all.models[[i]]$results$RMSE)))
}
all.models[[1]]$error
all.models[[2]]$error
all.models[[3]]$error
sort(sapply(all.models, function(x) min(as.vector(na.omit(x$results$RMSE)))))
all.models <- list()
all.models[[length(all.models)+1]] <- readRDS("gbm.rds")
all.models[[length(all.models)+1]] <- readRDS("svmRadial.rds")
all.models[[length(all.models)+1]] <- readRDS("rf.rds")
# sort the models from lowest to highest RMSE
names(all.models) <- sapply(all.models, function(x) x$method)
sort(sapply(all.models, function(x) min(as.vector(na.omit(x$results$RMSE)))))
for (i in 1:length(all.models)) {
all.models[[i]]$error <- min(as.vector(na.omit(all.models[[i]]$results$RMSE)))
}
sort(sapply(all.models, function(x) x$error))
all.models[[length(all.models)+1]] <- readRDS("greedy.rds")
sort(sapply(all.models, function(x) x$error))
all.models[[length(all.models)+1]] <- readRDS("linear.rds")
all.models[[length(all.models)+1]] <- readRDS("nonlinear.rds")
sort(sapply(all.models, function(x) x$error))
linear$error
greedy$error
nonlinear$error
nonliner$error <- min(nonliner$error$RMSE)
nonliner$error <- min(nonlinear$error$RMSE)
nonlinear$error <- min(nonlinear$error$RMSE)
nonlinear$error
saveRDS(nonlinear, file="nonlinear.rds")
linear$error <- min(linear$error$RMSE)
saveRDS(linear, file="linear.rds")
linear$error
all.models <- list()
all.models[[length(all.models)+1]] <- readRDS("gbm.rds")
all.models[[length(all.models)+1]] <- readRDS("svmRadial.rds")
all.models[[length(all.models)+1]] <- readRDS("rf.rds")
for (i in 1:length(all.models)) {
all.models[[i]]$error <- min(as.vector(na.omit(all.models[[i]]$results$RMSE)))
}
sort(sapply(all.models, function(x) x$error))
all.models[[length(all.models)+1]] <- readRDS("greedy.rds")
all.models[[length(all.models)+1]] <- readRDS("linear.rds")
all.models[[length(all.models)+1]] <- readRDS("nonlinear.rds")
sort(sapply(all.models, function(x) x$error))
greedy$error
linear$error
all.models <- list()
all.models[[length(all.models)+1]] <- readRDS("gbm.rds")
all.models[[length(all.models)+1]] <- readRDS("svmRadial.rds")
all.models[[length(all.models)+1]] <- readRDS("rf.rds")
names(all.models) <- sapply(all.models, function(x) x$method)
sort(sapply(all.models, function(x) min(as.vector(na.omit(x$results$RMSE)))))
# create a greedy ensemble that minimises the RMSE
greedy <- caretEnsemble(all.models, iter=1000L)
sort(greedy$weights, decreasing=TRUE)
saveRDS(greedy, file="greedy.rds")
greedy$error
# make a linear regression ensemble
linear <- caretStack(all.models, method='glm', trControl=trainControl(method='cv'))
saveRDS(linear, file="linear.rds")
# make a rf regression ensemble
tune.grid <- expand.grid(.mtry = seq(1,length(all.models),1))
nonlinear <- caretStack(all.models, method='rf', trControl=trainControl(method='cv'), tune.grid=tune.grid)
saveRDS(nonlinear, file="nonlinear.rds")
greedy$error
linear$error
nonlinear$error
sort(sapply(all.models, function(x) min(as.vector(na.omit(x$results$RMSE)))))
preds <- data.frame(sapply(all.models, predict, newdata=dataset$x.holdout))
preds$ENS_greedy <- predict(greedy, newdata=dataset$x.holdout)
preds$ENS_linear <- predict(linear, newdata=dataset$x.holdout)
preds$ENS_nonlinear <- predict(nonlinear, newdata=dataset$x.holdout)
sort(sqrt(colMeans((preds - dataset$y.holdout) ^ 2)))
greedy$error
linear$error
nonlinear$error
