<<<<<<< HEAD
}
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout)
#################################################################################
## Model Assessment and Results Visualization
#################################################################################
##############
ErrorBarplot <- function(Data,X,Y,err,colour=NULL,shape=NULL,fill=NULL,main="",ylab="",xlab="",
minn=NULL,maxx=NULL,TextSize=15,TitleSize=15,XAxisSize=15,YAxisSize=15,
TitleAxesSize=15,AngleLab=35,barcol="red",barSize=1,
barWidth=0.3, LegendName="Legend",ColLegend=1,
RowLegend=NULL,LegendPosition="right",
tmar=1,bmar=1,rmar=1,lmar=1,stat="identity"){
yerr_names <- names(Data)[c(Y,err)]
yerrbar <- aes_string(ymin = paste(yerr_names, collapse = '-'),
ymax = paste(yerr_names,collapse='+'))
p <- ggplot(Data, aes_string(x=names(Data)[X], y=names(Data)[Y],fill=fill,colour=colour,shape=shape)) + theme_bw() +
geom_bar(position="dodge",stat=stat)+
geom_errorbar(mapping=yerrbar,
position=position_dodge(0.9), width=barWidth,color=barcol,size=barSize)
return(p)
}
##############
plotGrid <- function(plots,NRows,NCols,HeightBlocks,MyLegend=NULL,LegendRight=NULL,filename=NULL,PDFheight=10,PDFwidth=10){
if(is.null(MyLegend) && length(HeightBlocks) != NRows){stop("The length of each column is given in HeightBlocks. Thus, the length of HeightBlocks should be equal to the number of columns")}
if(isnot.null(MyLegend) && length(HeightBlocks) != 2 && is.null(LegendRight)){stop("HeightBlocks defines the height of the plots and the legend. Therefore, its length has to be equal to 2")}
if(isnot.null(MyLegend) && isnot.null(LegendRight) && length(HeightBlocks) != NRows){stop("The length of each column is given in HeightBlocks. Thus, the length of HeightBlocks should be equal to the number of columns")}
if (is.null(filename)){
t <- c("grid.arrange(arrangeGrob(")
for (i in 1:length(plots)){
t <- paste(t,plots[i]," + theme(legend.position='none'),",sep="")
}
if (isnot.null(MyLegend)){
if (length(HeightBlocks)>1){
jj <-  c(paste0(HeightBlocks[1:length(HeightBlocks)-1],","),HeightBlocks[length(HeightBlocks)])
} else {
jj <- HeightBlocks[1]
}
jj <- paste(jj,collapse=" ")
t <- paste(t,"nrow= ",NRows ,", ncol= ",NCols,"),arrangeGrob(MyLegend,nrow=1),heights=c(",jj,"))" )
} else {
if (length(HeightBlocks)>1){
jj <-  c(paste0(HeightBlocks[1:length(HeightBlocks)-1],","),HeightBlocks[length(HeightBlocks)])
} else {
jj <- HeightBlocks[1]
}
jj <- paste(jj,collapse=" ")
t <- paste(t,"nrow= ",NRows ,", ncol= ",NCols ,", heights=c(",jj,")))" )
}
if(isnot.null(LegendRight)){
substr(t,nchar(t),nchar(t)) = ""
t <- paste(t,",ncol=2)")
}
return(eval(parse(text=t)))
} else {
t <- c("grid.arrange(arrangeGrob(")
for (i in 1:length(plots)){
t <- paste(t,plots[i]," + theme(legend.position='none'),",sep="")
}
if (isnot.null(MyLegend)){
if (length(HeightBlocks)>1){
jj <-  c(paste0(HeightBlocks[1:length(HeightBlocks)-1],","),HeightBlocks[length(HeightBlocks)])
} else {
jj <- HeightBlocks[1]
}
jj <- paste(jj,collapse=" ")
t <- paste(t,"nrow= ",NRows ,", ncol= ",NCols,"),arrangeGrob(MyLegend,nrow=1),heights=c(",jj,"))" )
} else {
if (length(HeightBlocks)>1){
jj <-  c(paste0(HeightBlocks[1:length(HeightBlocks)-1],","),HeightBlocks[length(HeightBlocks)])
} else {
jj <- HeightBlocks[1]
}
jj <- paste(jj,collapse=" ")
t <- paste(t,"nrow= ",NRows ,", ncol= ",NCols ,", heights=c(",jj,")))" )
}
if(isnot.null(LegendRight)){
substr(t,nchar(t),nchar(t)) = ""
t <- paste(t,",ncol=2)")
}
pdfname <- paste(filename,".pdf",sep="")
pdf(file=pdfname,width=PDFwidth,height=PDFheight)
eval(parse(text=t))
dev.off()
return(1)
}
}
##############
## Observed vs predicted
CorrelationPlot <- function (pred,obs,margin=NULL,main="",ylab="Observed",xlab="Predicted",
PointSize=4,ColMargin="blue",TextSize=15,TitleSize=15,
XAxisSize=15,YAxisSize=15,TitleAxesSize=15,tmar=1,bmar=1,
rmar=1,lmar=1,AngleLab=30,LegendPosition="right",PointColor="black",
PointShape=16,MarginWidth=1)
{
if (isnot.vector(obs) || isnot.vector(pred)){
stop("The input data must be two vectors")
} else if ( length(obs) != length(pred) ){
stop("Both vectors have to be of equal length")
} else if(isnot.null(margin)) {
Data <- data.frame(Observed=obs,Predicted=pred)
p <- ggplot(Data, aes(x=Observed, y=Predicted)) +
geom_point(size=PointSize,colour=PointColor,shape=PointShape) +
geom_abline(slope=1,intercept=margin/2,colour=ColMargin,size=MarginWidth) +
geom_abline(slope=1,intercept=-(margin/2),colour=ColMargin,size=MarginWidth) + theme_bw() +
ggtitle(main) + ylab(ylab) + xlab(xlab)+
ylim(c(min(c(obs,pred)), max(c(obs,pred)))) + xlim(c(min(c(obs,pred)), max(c(obs,pred)))) +
theme(text = element_text(size=TextSize),axis.text.x = element_text(size=XAxisSize,angle = AngleLab, hjust = 1),
axis.title.x=element_text(size=TitleAxesSize),axis.title.y=element_text(size=TitleAxesSize),
axis.text.y=element_text(size=YAxisSize),legend.position=LegendPosition,plot.title=element_text(size=TitleSize),
legend.key=element_blank(), plot.margin=unit(c(tmar,rmar,bmar,lmar),"cm"))
} else {
Data <- data.frame(Observed=obs,Predicted=pred)
p <- ggplot(Data, aes(x=Observed, y=Predicted)) + geom_point(size=PointSize,colour=PointColor,shape=PointShape) + theme_bw() +
ggtitle(main) + ylab(ylab) + xlab(xlab) +
ylim(c(min(c(obs,pred)), max(c(obs,pred)))) + xlim(c(min(c(obs,pred)), max(c(obs,pred)))) +
theme(text = element_text(size=TextSize),axis.text.x = element_text(size=XAxisSize,angle = AngleLab, hjust = 1),
axis.title.x=element_text(size=TitleAxesSize),axis.title.y=element_text(size=TitleAxesSize),
axis.text.y=element_text(size=YAxisSize),legend.position=LegendPosition,plot.title=element_text(size=TitleSize),
legend.key=element_blank(), plot.margin=unit(c(tmar,rmar,bmar,lmar),"cm"))
}
return(p)
}
# Functions to evaluate models performance
# Tropsha, A.; Golbraikh, A. Predictive Quantitative Structureâ€“Activity Relationships Modeling:
#Development and Validation of QSAR Models. In: Handbook of Chemoinformatics Algorithms
#(Faulon, J.-L.; Bender, A., Eds.), Chapter 7, pp. 213-233, Chapman & Hall / CRC, London, UK, 2010.
# calculates the RMSE between two vectors
RMSE <- function(v1, v2) {
i1 <- which(!is.na(v1))
i2 <- which(!is.na(v2))
is <- intersect(i1, i2)
v1 <- v1[is]
v2 <- v2[is]
residuals <- abs(v1-v2)
return(as.numeric(sqrt( (residuals%*%residuals)/length(v1) )))
}
RMSE_CV <- function(model, digits = 3) {
signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
}
# calculates the MAE between two vectors
MAE <- function (v1, v2) {
i1 <- which(!is.na(v1))
i2 <- which(!is.na(v2))
is <- intersect(i1, i2)
v1 <- v1[is]
v2 <- v2[is]
residuals <- abs(v1 - v2)
return(sum(residuals)/length(v1))
}
# Calculates the slope between two vector (k')
slope <- function(v1,v2){ # v1=z.test v2=y.test
return(sum(v2*v1)/sum(v1*v1))
}
# Calculates the regression coefficient through the origin
Rsquared0 <- function(v1,v2) { #v1=z.test (y), v2=y.test (x)
if (is.vector(v1) && is.vector(v2) && length(v1)==length(v2)){
y_obs_mean <- mean(v2)
yr0 = v1 * slope(v1,v2)
first_term = (v2 - yr0)*(v2 - yr0)
second_term= (v2-y_obs_mean)*(v2-y_obs_mean)
return(1-(sum(first_term)/sum(second_term)))
}
else {print("Wrong input: input arguments are not vector or have unequal length")}
}
# Calculates the regression coefficient
Rsquared <- function(v1,v2) { # v1=z.test (y), v2=y.test (x)
if (is.vector(v1) && is.vector(v2) && length(v1)==length(v2)){
y_obs_mean <- mean(v2)
y_pred_mean <- mean(v1)
first_term <- sum((v2-y_obs_mean) * (v1 - y_pred_mean))
second_term <- sqrt(sum((v2-y_obs_mean)*(v2-y_obs_mean)) * sum((v1 - y_pred_mean)*(v1 - y_pred_mean)))
division <- first_term / second_term
return(division * division)
}
else {print("Wrong input: input arguments are not vector or have unequal length")}
}
# Calculates the Q squared
#Qsquared (z.test,y.test) (predicted vs observed)
Qsquared <- function(v1, v2) {
if (is.vector(v1) && is.vector(v2) && length(v1)==length(v2)){
y_obs_mean <- mean(v2)
first_term <- abs(v1-v2)*abs(v1-v2)
second_term <- abs(v2-y_obs_mean)*abs(v2-y_obs_mean)
return(1-(sum(first_term)/sum(second_term)))
}
else {print("Wrong input: input arguments are not vector or have unequal length")}
}
##############
## Validation of models
Validation <- function(pred,obs){
if (is.vector(pred) && is.vector(obs) && length(pred)==length(obs)){
metrics <- list(R2 = Rsquared(pred,obs), R02 = Rsquared0(pred,obs), Q2 = Qsquared(pred,obs), RMSE = RMSE(pred,obs), Slope=slope(pred,obs), MAE = MAE(pred, obs))
} else {
stop("Wrong input: input arguments are not vector or have unequal length")
}
return(metrics)
}
################################
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout)
library("camb", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout)
library(ggplot2)
library(doMC)
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout)
model
length(dataset$y.holdout)
length(dataset$y.train)
model
holdout.predictions <- as.vector(predict(model, newdata = dataset$x.holdout))
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout)
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout)
RMSE_CV(model)
tune.grid <- expand.grid(.sigma = expGrid(ini=-8, end=4, stride=2, base=2), .C = c(0.0001, 0.001, 0.01, 0.1, 1, 10, 100))
expGrid <- function(power.from, power.to, power.by, base){
grid <- c()
for (i in seq(power.from, power.to, power.by)){
grid <- append(grid,base^i)
}
return(grid)
}
tune.grid <- expand.grid(.sigma = expGrid(-8, 4, 2, 2), .C = c(0.0001, 0.001, 0.01, 0.1, 1, 10, 100))
tune.grid
saveRDS(dataset, file="dataset.rds")
dataset <- readRDS("dataset.rds")
model <- readRDS("rf.rds")
setwd("~/Dropbox/projects/camb/examples/LogS/Reference_1")
setwd("~/Dropbox/projects/camb/examples/LogS/Reference_2")
model <- readRDS("svmRadial.rds")
model
Rsquared_CV <- function(model, digits = 3) {
model$results$Rsquared[which(model$results$RMSE %in% min(model$results$RMSE, na.rm=TRUE))]
}
RMSE_CV(model)
Rsquared_CV(model)
holdout.predictions <- as.vector(predict(model, newdata = dataset$x.holdout))
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout)
holdout.predictions
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout, margin=1)
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout, margin=2)
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout, margin=1)
metrics <- Validation(holdout.predictions, dataset$y.holdout)
metrics
model <- readRDS("svmRadial.rds")
library(errorestimatoR)
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout)
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout, margin=1, main="LogS Observered vs Predicted", PointSize=0.2, ColMargin="red")
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout, margin=1, main="LogS Observered vs Predicted", PointSize=0.5, ColMargin="red")
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout, margin=1, main="LogS Observered vs Predicted", PointSize=2, ColMargin="red")
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout, margin=1, main="LogS Observered vs Predicted", PointSize=3, ColMargin="red")
p <- DensityResponse(targets$target)
p + labs(title="LogS target value distribution")
PreProcess
?preProcess
PreProcess
preProcess(ss$x.train, method=c("center", "scale", "blob"))
preProcess
preProcess.default
?preProcess
sigpred <- PredictSigmas(x=ss$x.holdout, estimator)
model
preds <- predict(model, newdata = ss$x.holdout)
errors <- preds - ss$y.holdout
plot(sigpred$sigmas, errors)
CEC(sigpred$sigmas, abs(errors))
sigpred$sigma.matrix[,2]
CEC(sigpred$sigma.matrix[,2], abs(errors))
CEC(sigpred$sigma.matrix[,1], abs(errors))
CEC(sigpred$sigma.matrix[,2], abs(errors))
plot(sigpred$sigmas, errors)
plot(errors, sigpred$sigmas)
plot(errors, sigpred$sigma.matrix[,2])
plot(errors, sigpred$sigma.matrix[,2])
plot(errors, sigpred$sigmas)
plot(errors, sigpred$sigma.matrix[,2])
plot(errors, sigpred$sigmas)
rbf
rbfdot
model
k <- rbfdot(sigma=0.00391)
k(x=1, y=1)
k(x=2, y=1)
k(x=0, y=1)
k(x=0, y=2)
k(x=0, y=3)
k(x=0, y=100)
k(x=0, y=10)
k(0,1)
k(1,2)
k(1)
k(2)
k(3)
library("errorestimatoR", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
library(errorestimatoR)
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
model <- readRDS("svmRadial.rds")
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
library(errorestimatoR)
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
matrix(rnorm(20), 4, 5)
m <- matrix(rnorm(20), 4, 5)
v <- rnorm(5)
k <- rbfdot(sigma=0.00391)
k <- rbfdot(sigma=0.00391)
library(kernlab)
k <- rbfdot(sigma=0.00391)
apply(m, 1, k, v)
m
1- apply(m, 1, k, v)
apply(m, 1, k, v)
1 - apply(m, 1, k, v)
model <- readRDS("svmRadial.rds")
library(errorestimatoR)
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
model <- readRDS("svmRadial.rds")
library(errorestimatoR)
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
setwd("~/Dropbox/projects/camb/examples/LogS/Reference_2")
model <- readRDS("svmRadial.rds")
library(errorestimatoR)
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
model
indexes <- which(apply(as.data.frame(model$pred[,names(model$bestTune)]), 1, function(x,y) {identical(as.numeric(x), as.numeric(y))}, model$bestTune))
best <- model$pred[indexes,]
order <- order(best$rowIndex, decreasing=FALSE)
best <- best[order,]
obs <- best$obs
preds <- best$pred
fold.strings <- unique(best$Resample)
folds <- list()
for(fold in 1:length(fold.strings)) {
folds[[fold]] <- which(best$Resample == fold.strings[fold])
}
folds
indexes <- which(apply(as.data.frame(model$pred[,names(model$bestTune)]), 1, function(x,y) {identical(as.numeric(x), as.numeric(y))}, model$bestTune))
best <- model$pred[indexes,]
order <- order(best$rowIndex, decreasing=FALSE)
best <- best[order,]
obs <- best$obs
preds <- best$pred
fold.strings <- unique(best$Resample)
folds <- list()
for(fold in 1:length(fold.strings)) {
folds[[fold]] <- which(best$Resample == fold.strings[fold])
}
folds
errors <- preds - obs
dms <- CreateDistanceMatricesMC(x, folds, cores)
dms <- CreateDistanceMatricesMC(x, folds, 1)
Nmax
x
x <- dataset$x.train
dataset <- readRDS("dataset.rds")
x <- dataset$x.train
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
dim(model$trainingData)
f
is.null(f)
exists(bob)
exists("bob")
exists("dataset")
estimator = BuildCaretErrorEstimator(bob, model, Nmax=20, cores=1)
BuildCaretErrorEstimator <- function(x, model, Nmax = 20, cores=1, optFunc = CEC) {
if(!exists("x")) {
print("x doesn't exist")
return
}
indexes <- which(apply(as.data.frame(model$pred[,names(model$bestTune)]), 1, function(x,y) {identical(as.numeric(x), as.numeric(y))}, model$bestTune))
best <- model$pred[indexes,]
order <- order(best$rowIndex, decreasing=FALSE)
best <- best[order,]
obs <- best$obs
preds <- best$pred
fold.strings <- unique(best$Resample)
folds <- list()
for(fold in 1:length(fold.strings)) {
folds[[fold]] <- which(best$Resample == fold.strings[fold])
}
BuildEstimator(x, folds, obs, preds, Nmax, cores, optFunc)
}
estimator = BuildCaretErrorEstimator(bob, model, Nmax=20, cores=1)
BuildCaretErrorEstimator <- function(x, model, Nmax = 20, cores=1, optFunc = CEC) {
if(!exists("x")) {
print("x doesn't exist")
return
}
indexes <- which(apply(as.data.frame(model$pred[,names(model$bestTune)]), 1, function(x,y) {identical(as.numeric(x), as.numeric(y))}, model$bestTune))
best <- model$pred[indexes,]
order <- order(best$rowIndex, decreasing=FALSE)
best <- best[order,]
obs <- best$obs
preds <- best$pred
fold.strings <- unique(best$Resample)
folds <- list()
for(fold in 1:length(fold.strings)) {
folds[[fold]] <- which(best$Resample == fold.strings[fold])
}
BuildEstimator(x, folds, obs, preds, Nmax, cores, optFunc)
}
library(errorestimatoR)
dataset <- readRDS("dataset.rds")
model <- readRDS("svmRadial.rds")
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
setwd("~/Dropbox/projects/camb/examples/LogS/Reference_2")
dataset <- readRDS("dataset.rds")
model <- readRDS("svmRadial.rds")
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
setwd("~/Dropbox/projects/camb/examples/LogS/Reference_2")
setwd("~/Dropbox/projects/camb/examples/LogS/Reference_2")
dataset <- readRDS("dataset.rds")
model <- readRDS("svmRadial.rds")
library(errorestimatoR)
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
dataset$x.train
indexes <- which(apply(as.data.frame(model$pred[,names(model$bestTune)]), 1, function(x,y) {identical(as.numeric(x), as.numeric(y))}, model$bestTune))
best <- model$pred[indexes,]
order <- order(best$rowIndex, decreasing=FALSE)
best <- best[order,]
obs <- best$obs
preds <- best$pred
fold.strings <- unique(best$Resample)
folds <- list()
for(fold in 1:length(fold.strings)) {
folds[[fold]] <- which(best$Resample == fold.strings[fold])
}
folds
BuildEstimator(x, folds, obs, preds, Nmax, cores, optFunc)
BuildEstimator(x, folds, obs, preds, Nmax, 1, CEC)
BuildEstimator(x, folds, obs, preds, 20, 1, CEC)
exists("dataset")
setwd("~/Dropbox/projects/camb/examples/LogS/Reference_2")
dataset <- readRDS("dataset.rds")
dataset <- readRDS("dataset.rds")
model <- readRDS("svmRadial.rds")
library(errorestimatoR)
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
indexes <- which(apply(as.data.frame(model$pred[,names(model$bestTune)]), 1, function(x,y) {identical(as.numeric(x), as.numeric(y))}, model$bestTune))
best <- model$pred[indexes,]
order <- order(best$rowIndex, decreasing=FALSE)
best <- best[order,]
obs <- best$obs
preds <- best$pred
fold.strings <- unique(best$Resample)
folds <- list()
for(fold in 1:length(fold.strings)) {
folds[[fold]] <- which(best$Resample == fold.strings[fold])
}
folds
BuildEstimator(dataset$x.train, folds, obs, preds, 20, 1, CEC)
BuildEstimator
Nmax <- 20
cores <- 1
optFunc <- CEC
errors <- preds - obs
dms <- CreateDistanceMatricesMC(x, folds, cores)
x <- dataset$x.train
dms <- CreateDistanceMatricesMC(x, folds, cores)
dms <- CreateDistanceMatricesMC(x, folds, cores)
CreateDistanceMatricesMC
mclapply(1:length(folds), CreateDistanceFold, x.train, folds, mc.cores = max(length(folds), cores))
library(kernlab)
mclapply(1:length(folds), CreateDistanceFold, x.train, folds, mc.cores = max(length(folds), cores))
mclapply(1:length(folds), CreateDistanceFold, dataset$x.train, folds, mc.cores = max(length(folds), cores))
setwd("~/Dropbox/projects/camb/examples/LogS/Reference_2")
dataset <- readRDS("dataset.rds")
model <- readRDS("svmRadial.rds")
library(errorestimatoR)
library(kernlab)
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
sigpred <- PredictSigmas(x=ss$x.holdout, estimator)
preds <- predict(model, newdata = dataset$x.holdout)
sigpred <- PredictSigmas(x=dataset$x.holdout, estimator)
errors <- preds - ss$y.holdout
CEC(sigpred$sigmas, abs(errors))
errors <- preds - dataset$y.holdout
CEC(sigpred$sigmas, abs(errors))
plot(errors, sigpred$sigmas)
detach("package:errorestimatoR", unload=TRUE)
library("errorestimatoR", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
estimator2 = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
sigpred2 <- PredictSigmas(x=dataset$x.holdout, estimator)
sigpred2 <- PredictSigmas(x=dataset$x.holdout, estimator2)
CEC(sigpred2$sigmas, abs(errors))
plot(errors, sigpred2$sigmas)
CEC(sigpred2$sigma.matrix[,2], abs(errors))
?rbfdot
k <- rbfdot(sigma = 0.2)
k
model <- readRDS("rf.rds")
estimator3 = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
sigpred3 <- PredictSigmas(x=dataset$x.holdout, estimator3)
preds <- predict(model, newdata = dataset$x.holdout)
errors <- preds - dataset$y.holdout
plot(errors, sigpred3$sigmas)
CEC(sigpred3$sigmas, abs(errors))
detach("package:errorestimatoR", unload=TRUE)
library("errorestimatoR", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
estimator4 = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
sigpred4 <- PredictSigmas(x=dataset$x.holdout, estimator4)
preds <- predict(model, newdata = dataset$x.holdout)
errors <- preds - dataset$y.holdout
plot(errors, sigpred4$sigmas)
CEC(sigpred4$sigmas, abs(errors))
CEC(sigpred3$sigma.matrix[,2], abs(errors))
CEC(sigpred4$sigma.matrix[,2], abs(errors))
apply(sigpred4$sigma.matrix, 2, CEC, abs(errors))
plot(density(apply(sigpred4$sigma.matrix, 2, CEC, abs(errors))))
plot(density(apply(sigpred4$sigma.matrix, 2, CEC, abs(errors)), bw=0.1))
plot(density(apply(sigpred4$sigma.matrix, 2, CEC, abs(errors)), bw=0.01))
plot(apply(sigpred4$sigma.matrix, 2, CEC, abs(errors)), bw=0.01)
plot(apply(sigpred4$sigma.matrix, 2, CEC, abs(errors)))
?train
=======
?train
library(caret)
?train
library(camb)
?StandardiseMolecules
library(camb)
library(ggplot2)
setwd("~/Dropbox/projects/camb/examples/LogS/Reference_2")
setwd("~/Dropbox/projects/camb/examples/QSPR/LogS/Reference_2")
StandardiseMolecules(structures.file="solubility_2007_ref2.sdf",
standardised.file="standardised.sdf",
removed.file="removed.sdf",
output = "properties.csv",
remove.inorganic=TRUE,
fluorine.limit=3,
chlorine.limit=3,
bromine.limit=3,
iodine.limit=3,
min.mass.limit=20,
max.mass.limit=900)
descriptors <- GeneratePadelDescriptors(standardised.file = "standardised.sdf", types=c("2D"), threads = 1)
setwd("~/Dropbox/projects/camb/examples/QSPR/LogS/Reference_2")
library(camb)
library(ggplot2)
setwd("~/Dropbox/projects/camb/examples/QSPR/LogS/Reference_2")
StandardiseMolecules(structures.file="solubility_2007_ref2.sdf",
standardised.file="standardised.sdf",
removed.file="removed.sdf",
output = "properties.csv",
remove.inorganic=TRUE,
fluorine.limit=3,
chlorine.limit=3,
bromine.limit=3,
iodine.limit=3,
min.mass.limit=20,
max.mass.limit=900)
descriptors <- GeneratePadelDescriptors(standardised.file = "standardised.sdf", types=c("2D"), threads = 1)
descriptors <- RemoveStandardisedPrefix(descriptors)
descriptors <- RemoveStandardisedPrefix(descriptors)
properties <- read.csv("properties.csv")
properties <- properties[properties$Kept==1, ]
properties
head(properties)
>>>>>>> e07b0708d708c3ba1fc1c5c2123bee363b2657a3
