names(m)[1:10]
names(t)
names(df)
t <- read.table("namefile.txt")
e("namefile.txt")
predictions10 <- PredictLogP(structures.file="../../../smPredict/testing_package/structures_10.sdf", debug=TRUE, threads=4)
t <- read.table("namefile.txt")
t <- read.table("nametxt")
setwd("/Users/daniel/Dropbox/projects/logP_workflow/7_external_test_new/4_prediction")
t <- read.table("name.txt")
df <- data.frame(number = 1:nrow(t), Name = as.character(t[,1]))
descs <- read.csv("descriptors.csv")
m <- merge(df, descs, by.x="number", by.y="Name")
names(m)[1:10]
write.csv(m[, 2:ncol(m)], "descriptors.csv", row.names=FALSE)
predictions10 <- PredictLogP(structures.file="../../../smPredict/testing_package/structures_10.sdf", debug=TRUE, threads=4)
detach(package:smPredict, unload=TRUE)
library(smPredict)
library(dsmR)
predictions10 <- PredictLogP(structures.file="../../../smPredict/testing_package/structures_10.sdf", debug=TRUE, threads=4)
predictions10
cbind(predictions10, predictions3)
detach(package:smPredict, unload=TRUE)
library(smPredict)
library(dsmR)
predictions <- PredictLogP(structures.file="../1_original_data/D1_pkkb_logP_only.sdf", debug=FALSE, threads=4)
name.file <- "name.txt"
descriptors.file <- "descriptors.csv"
t <- read.table(name.file)
print(line)
readCon  <- file(name.file, open = "r")
while (length(line <- readLines(readCon, n = 1, warn = FALSE)) > 0) {
print(line)
}
descs <- read.csv(descriptors.file)
df <- data.frame(number = 1:nrow(nrow(descs)))
nrow(descs)
df <- data.frame(number = 1:nrow(descs))
df
df <- data.frame(number = 1:nrow(descs))
readCon  <- file(name.file, open = "r")
names <- c()
while (length(line <- readLines(readCon, n = 1, warn = FALSE)) > 0) {
names <- c(names,line)
}
df$Name <- names
m <- merge(df, descs, by.x="number", by.y="Name")
name.file <- "name.txt"
descriptors.file <- "descriptors.csv"
descs <- read.csv(descriptors.file)
df <- data.frame(number = 1:nrow(descs))
readCon  <- file(name.file, open = "r")
names <- c()
while (length(line <- readLines(readCon, n = 1, warn = FALSE)) > 0) {
names <- c(names,line)
}
close(readCon)
df$Name <- names
m <- merge(df, descs, by.x="number", by.y="Name")
write.csv(m[, 2:ncol(m)], descriptors.file, row.names=FALSE)
setwd("/Users/daniel/Dropbox/projects/smPredict/testing_package")
detach(package:smPredict, unload=TRUE)
library(smPredict)
PredictLogP(structures.file="structures_10.sdf", debug=TRUE)
detach(package:smPredict, unload=TRUE)
library(smPredict)
PredictLogP(structures.file="structures_10.sdf", debug=TRUE)
detach(package:smPredict, unload=TRUE)
library(smPredict)
PredictLogP(structures.file="structures_10.sdf", debug=TRUE)
predictions
PredictLogP(structures.file="structures_10.sdf", debug=TRUE)
setwd("/Users/daniel/Dropbox/projects/logP_workflow/7_external_test_new/4_prediction")
detach(package:smPredict, unload=TRUE)
t, unload=TRUE)
detach(package:smPredict, unload=TRUE)
library(smPredict)
library(dsmR)
predictions <- PredictLogP(structures.file="../1_original_data/D1_pkkb_logP_only.sdf", debug=FALSE, threads=1)
dim(predictions)
predictions
?train
setwd("/Users/daniel/Dropbox/projects/smPredict/testing_package")
detach(package:smPredict, unload=TRUE)
library(smPredict)
PredictLogP(structures.file="structures_10.sdf", debug=TRUE)
csv <- read.csv("descriptors.csv")
ncol(csv)
?t.test
seq(0.1, 0.5, 0.1)
i <- 3
paste("results", i, ".pdf", sep="")
paste("gpe", i, ".rda", sep="")
i <- 0.2
paste("gpe", i, ".rda", sep="")
setwd("/Users/daniel/Dropbox/projects/logP_workflow/ensembles_new/gpe")
setwd("/Users/daniel/Dropbox/projects/logP_workflow/ensembles_small/gpe")
load("gpe0.1.rda")
load("../data.rda")
gpe$results
setwd("/Users/daniel/Dropbox/projects/logP_workflow/ensembles_new/gpe")
load("../data.rda")
load("gpe0.1.rda")
gpe$results
CVRMSE <- signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
model <- gpe
CVRMSE <- signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
testRMSE <- signif(RMSE(as.vector(predict(model, newdata = x.test)), y.test), digits=3)
testRMSE
plot(model, metric = "RMSE", main=paste("CV RMSE:", CVRMSE, "    Test RMSE", testRMSE))
object.size(gpe)
object.size(gpe$finalModel)
i <- 0.1
paste("results", i, ".pdf", sep="")
pdf(paste("results", i, ".pdf", sep=""))
CVRMSE <- signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
testRMSE <- signif(RMSE(as.vector(predict(model, newdata = x.test)), y.test), digits=3)
plot(model, metric = "RMSE", main=paste("CV RMSE:", CVRMSE, "    Test RMSE", testRMSE))
dev.off()
library(caret)
library(caretEnsemble)
load("data.rda")
setwd("/Users/daniel/Dropbox/projects/logP_workflow/ensembles_new")
library(caret)
library(caretEnsemble)
load("data.rda")
all.models <- list()
load("gbm/gbm.rda")
all.models[[length(all.models)+1]] <- gbm
load("svm/svm.rda")
all.models[[length(all.models)+1]] <- svm
load("gpe/gpe0.1.rda")
all.models[[length(all.models)+1]] <- gpe
names(all.models) <- sapply(all.models, function(x) x$method)
sort(sapply(all.models, function(x) min(as.vector(na.omit(x$results$RMSE)))))
greedy <- caretEnsemble(all.models, iter=1000L)
sort(greedy$weights, decreasing=TRUE)
greedy$error
linear <- caretStack(all.models, method='glm', trControl=trainControl(method='cv'))
summary(linear$ens_model$finalModel)
linear$error
preds <- data.frame(sapply(all.models, predict, newdata=x.test))
preds$ENS_greedy <- predict(greedy, newdata=x.test)
preds$ENS_linear <- predict(linear, newdata=x.test)
#preds$ENS_nonlinear <- predict(nonlinear, newdata=x.test)
sort(sqrt(colMeans((preds - y.test) ^ 2)))
seq(0.1, 0.5, 0.1)
setwd("/Users/daniel/Dropbox/projects/logP_workflow/ensembles_small/gpe")
load("gpe0.1.rda")
i <- 0.1
pdf(paste("results", i, ".pdf", sep=""))
CVRMSE <- signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
testRMSE <- signif(RMSE(as.vector(predict(model, newdata = x.test)), y.test), digits=3)
plot(model, metric = "RMSE", main=paste("CV RMSE:", CVRMSE, "    Test RMSE", testRMSE))
dev.off()
model <- gpe
i <- 0.1
pdf(paste("results", i, ".pdf", sep=""))
CVRMSE <- signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
testRMSE <- signif(RMSE(as.vector(predict(model, newdata = x.test)), y.test), digits=3)
plot(model, metric = "RMSE", main=paste("CV RMSE:", CVRMSE, "    Test RMSE", testRMSE))
dev.off()
setwd("/Users/daniel/Dropbox/projects/logP_workflow/ensembles_small/gpe")
load("../data.rda")
load("gpe0.1.rda")
i <- 0.1
model <- gpe
pdf(paste("results", i, ".pdf", sep=""))
CVRMSE <- signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
testRMSE <- signif(RMSE(as.vector(predict(model, newdata = x.test)), y.test), digits=3)
plot(model, metric = "RMSE", main=paste("CV RMSE:", CVRMSE, "    Test RMSE", testRMSE))
dev.off()
seq(0.1, 0.5, 0.1)
setwd("/Users/daniel/Dropbox/projects/logP_workflow/ensembles_tiny")
#packages <- list('caret',
#                 'randomForest',
#                 'kernlab',
#                 'impute',
#                 'doMC',
#                 'dsmR',
#                 'R.utils',
#                 'ipred')
#for(package in packages) {
#  stopifnot(require(package, character.only = TRUE))
#}
library(caret)
data <- read.csv(file = "../4_target_and_descriptors/target_and_descriptors_imputed.csv")
y <- data$logP
killset <- expression(c(Name, logP, ALogP, ALogp2, XLogP, MLogP, LipoaffinityIndex))
x <- subset(data, select = -eval(killset))
testPercentage <- 95
testSize <- round(nrow(data) * (testPercentage/100))
set.seed(1)
test <- sample(1:nrow(data), testSize, replace=FALSE)
train <- (1:length(y))[-test]
x.train <- x[train, ]
x.test <- x[test, ]
y.train <- y[train]
y.test <- y[test]
nzv.columns <- nearZeroVar(x.train, freqCut = 30/1)
if (length(nzv.columns) != 0) {
nzv.names <- names(x.train)[nzv.columns]
x.train <- x.train[, -nzv.columns]
x.test <- x.test[, -nzv.columns]
}
is.highly.correlated <- findCorrelation(cor(x.train), 0.95)
if (length(is.highly.correlated) != 0) {
x.train <- x.train[, -is.highly.correlated]
x.test <- x.test[, -is.highly.correlated]
}
transformation <- preProcess(x.train, method = c("center", "scale"))
x.train <- predict(transformation, x.train)
x.test <- predict(transformation, x.test)
set.seed(1)
folds=5
repeats=1
trControl <- trainControl(method='cv', number=folds, repeats=repeats, returnResamp='none',
returnData=FALSE, savePredictions=TRUE,
verboseIter=TRUE, allowParallel=TRUE,
index=createMultiFolds(y.train, k=folds, times=repeats))
save.image(file="data.rda")
dim(x.train)
setwd("/Users/daniel/Dropbox/projects/logP_workflow/ensembles_tiny/gpe")
library(caret)
library(doMC)
library(kernlab)
load("../data.rda")
registerDoMC(cores=14)
tune.grid <- expand.grid(.sigma = c(0.001, 0.002, 0.003))
for(i in seq(0.1, 0.5, 0.1)) {
print(paste("i equals ", i))
gpe <- train(x.train, y.train, "gaussprRadial", tuneGrid=tune.grid, trControl=trControl, variance.model=TRUE, var = i)
save(gpe, file=paste("gpe", i, ".rda", sep=""))
model <- gpe
pdf(paste("results", i, ".pdf", sep=""))
CVRMSE <- signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
testRMSE <- signif(RMSE(as.vector(predict(model, newdata = x.test)), y.test), digits=3)
plot(model, metric = "RMSE", main=paste("CV RMSE:", CVRMSE, "    Test RMSE", testRMSE))
dev.off()
}
warnings()
gpe
load("gpe0.1.rda")
gpe
load("gpe0.2.rda")
gpe
load("gpe0.3.rda")
gpe
model <- gpe
CVRMSE <- signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
CVRMSE
testRMSE <- signif(RMSE(as.vector(predict(model, newdata = x.test)), y.test), digits=3)
testRMSE
plot(model, metric = "RMSE", main=paste("CV RMSE:", CVRMSE, "    Test RMSE", testRMSE))
library(caret)
library(doMC)
library(kernlab)
load("../data.rda")
registerDoMC(cores=1)
tune.grid <- expand.grid(.sigma = c(0.001, 0.002, 0.003))
for(i in seq(0.1, 0.5, 0.1)) {
print(paste("i equals ", i))
gpe <- train(x.train, y.train, "gaussprRadial", tuneGrid=tune.grid, trControl=trControl, variance.model=TRUE, var = i)
save(gpe, file=paste("gpe", i, ".rda", sep=""))
model <- gpe
pdf(paste("results", i, ".pdf", sep=""))
CVRMSE <- signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
testRMSE <- signif(RMSE(as.vector(predict(model, newdata = x.test)), y.test), digits=3)
plot(model, metric = "RMSE", main=paste("CV RMSE:", CVRMSE, "    Test RMSE", testRMSE))
dev.off()
}
library(caret)
library(doMC)
library(kernlab)
load("../data.rda")
registerDoMC(cores=1)
tune.grid <- expand.grid(.sigma = c(0.001, 0.002, 0.003))
for(i in seq(0.1, 0.5, 0.1)) {
print(paste("i equals ", i))
gpe <- train(x.train, y.train, "gaussprRadial", tuneGrid=tune.grid, trControl=trControl, variance.model=TRUE, var = i)
save(gpe, file=paste("gpe", i, ".rda", sep=""))
model <- gpe
pdf(paste("results", i, ".pdf", sep=""))
CVRMSE <- signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
testRMSE <- signif(RMSE(as.vector(predict(model, newdata = x.test)), y.test), digits=3)
plot(model, metric = "RMSE", main=paste("CV RMSE:", CVRMSE, "    Test RMSE", testRMSE))
dev.off()
}
setwd("/Users/daniel/Dropbox/projects/logP_workflow/ensembles_tiny/gpe")
load("../data.rda")
load("gpe0.1.rda")
gpe
model <- gpe
CVRMSE <- signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
testRMSE <- signif(RMSE(as.vector(predict(model, newdata = x.test)), y.test), digits=3)
plot(model, metric = "RMSE", main=paste("CV RMSE:", CVRMSE, "    Test RMSE", testRMSE))
library(caret)
library(doMC)
library(kernlab)
load("../data.rda")
registerDoMC(cores=1)
tune.grid <- expand.grid(.sigma = c(0.001, 0.002, 0.003))
for(i in seq(0.1, 0.5, 0.1)) {
print(paste("i equals ", i, ".pdf"))
gpe <- train(x.train, y.train, "gaussprRadial", tuneGrid=tune.grid, trControl=trControl, variance.model=TRUE, var = i)
save(gpe, file=paste("gpe", i, ".rda", sep=""))
model <- gpe
pdf(paste("results", i, ".pdf", sep=""))
CVRMSE <- signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
testRMSE <- signif(RMSE(as.vector(predict(model, newdata = x.test)), y.test), digits=3)
plot(model, metric = "RMSE", main=paste("CV RMSE:", CVRMSE, "    Test RMSE", testRMSE))
dev.off()
}
load("../data.rda")
load("gpe0.1.rda")
gpe
model <- gpe
i <- 0.1
pdf(paste("results", i, ".pdf", sep=""))
CVRMSE <- signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
testRMSE <- signif(RMSE(as.vector(predict(model, newdata = x.test)), y.test), digits=3)
plot(model, metric = "RMSE", main=paste("CV RMSE:", CVRMSE, "    Test RMSE", testRMSE))
dev.off()
library(caret)
library(doMC)
library(kernlab)
load("../data.rda")
registerDoMC(cores=1)
tune.grid <- expand.grid(.sigma = c(0.001, 0.002, 0.003))
for(i in seq(0.1, 0.5, 0.1)) {
print(paste("i equals ", i))
gpe <- train(x.train, y.train, "gaussprRadial", tuneGrid=tune.grid, trControl=trControl, variance.model=TRUE, var = i)
save(gpe, file=paste("gpe", i, ".rda", sep=""))
model <- gpe
pdf(paste("results", i, ".pdf", sep=""))
CVRMSE <- signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
testRMSE <- signif(RMSE(as.vector(predict(model, newdata = x.test)), y.test), digits=3)
print(plot(model, metric = "RMSE", main=paste("CV RMSE:", CVRMSE, "    Test RMSE", testRMSE)))
dev.off()
}
setwd("/Users/daniel/Dropbox/projects/logP_workflow/ensembles_small/gpe")
load("gpe0.1.rda")
load("../data.rda")
error.bar <- function(x, y, upper, lower=upper, length=0.1,...){
if(length(x) != length(y) | length(y) !=length(lower) | length(lower) != length(upper))
stop("vectors must be same length")
arrows(x,y+upper, x, y-lower, angle=90, code=3, length=length, ...)
}
z.test <- as.vector(predict(gpe$finalModel, newdata = x.test))
z.test_var <- as.vector(predict(gpe$finalModel, newdata = x.test, type="variance"))
length(z.test)
length(z.test_var)
save(z.test_var, "z.test_var.rda")
save(z.test_var, file="z.test_var.rda")
axes.max <- max(c(max(z.test),max(y.test)))
axes.min <- min(c(min(z.test),min(y.test)))
axes.max
axes.min
plot(y.test,z.test, xlim=c(axes.min,axes.max), ylim=c(axes.min,axes.max), main="GP Poly NO FS.Observed (x) vs Predicted (y). Variance", xlab ="Observed", ylab="Predicted")
abline(jj)
setwd("/Users/daniel/Dropbox/projects/logP_workflow/ensembles_small/gpe_backup")
load("gpe0.1.rda")
i <- 0.1
pdf(paste("results", i, ".pdf", sep=""))
CVRMSE <- signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
testRMSE <- signif(RMSE(as.vector(predict(model, newdata = x.test)), y.test), digits=3)
plot(model, metric = "RMSE", main=paste("CV RMSE:", CVRMSE, "    Test RMSE", testRMSE))
dev.off()
i <- 0.1
model <- gpe
pdf(paste("results", i, ".pdf", sep=""))
CVRMSE <- signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
testRMSE <- signif(RMSE(as.vector(predict(model, newdata = x.test)), y.test), digits=3)
plot(model, metric = "RMSE", main=paste("CV RMSE:", CVRMSE, "    Test RMSE", testRMSE))
dev.off()
load("gpe0.1.rda")
error.bar <- function(x, y, upper, lower=upper, length=0.1,...){
if(length(x) != length(y) | length(y) !=length(lower) | length(lower) != length(upper))
stop("vectors must be same length")
arrows(x,y+upper, x, y-lower, angle=90, code=3, length=length, ...)
}
load("../data.rda")
setwd("/Users/daniel/Dropbox/projects/logP_workflow/ensembles_small/gpe_backup")
load("../data.rda")
z.test <- as.vector(predict(gpe$finalModel, newdata = x.test))
load("z.test_var.rda")
axes.max <- max(c(max(z.test),max(y.test)))
axes.min <- min(c(min(z.test),min(y.test)))
y.test <- y.test[1:100]
z.test <- z.test[1:100]
z.test_var <- z.test_var[1:100]
axes.max <- max(c(max(z.test),max(y.test)))
axes.min <- min(c(min(z.test),min(y.test)))
plot(y.test,z.test, xlim=c(axes.min,axes.max), ylim=c(axes.min,axes.max), main="GP Poly NO FS.Observed (x) vs Predicted (y). Variance", xlab ="Observed", ylab="Predicted")
error.bar(y.test,z.test,z.test_var,col="red")
error.bar(y.test,z.test,z.test_var + variance[i],col="red")
plot(z.test_var,abs(y.test-z.test))
plot(abs(y.test-z.test),z.test_var)
x.test <- x.test[1:100]
train_colums <- colSums(x.train)
distances <- c()
for(i in 1:nrow(x.test)){
distances[i] <- euc.dist(x.test[i,],train_colums)
}
euc.dist <- function(x1,x2){
sqrt(sum((x1 - x2) ^ 2))
}
train_colums <- colSums(x.train)
distances <- c()
for(i in 1:nrow(x.test)){
distances[i] <- euc.dist(x.test[i,],train_colums)
}
setwd("/Users/daniel/Dropbox/projects/logP_workflow/tetko_molecules")
setwd("/Users/daniel/Dropbox/projects/logP_workflow/tetko_molecules")
setwd("/Users/daniel/Dropbox/projects/logP_workflow/tetko_molecules")
setwd("/Users/daniel/Dropbox/projects/logP_workflow/tetko_molecules")
setwd("/Users/daniel/Dropbox/projects/logP_workflow/tetko_molecules")
setwd("/Users/daniel/Dropbox/projects/logP_workflow/tetko_molecules")
setwd("/Users/daniel/Dropbox/projects/logP_workflow/tetko_molecules")
setwd("/Users/daniel/Dropbox/projects/logP_workflow/tetko_molecules")
setwd("/Users/daniel/Dropbox/projects/logP_workflow/tetko_molecules")
setwd("/Users/daniel/Dropbox/projects/logP_workflow/tetko_molecules")
d <- read.csv("tetkosmallset.csv")
head(d)
star <- which(d$DATASET.log10 == "BioByte star")
star
dstar <- d[star,]
dnstar <- d[-star,]
smiles <- data.frame(SMILES = d$SMILES, ID=d$MOLECULEID)
smiles <- data.frame(SMILES = d$SMILES, external_id=d$MOLECULEID)
write.table(x=smiles, file=paste("tetkosmall", "_SMILES.smi", sep=""), quote=FALSE, sep=' ', row.names = FALSE, col.names = FALSE)
library(smPredict)
PredictLogP(structures.file="2D_tetkosmall_SMILES.smi", threads=1, debug=TRUE)
?trainControl
library(rJava)
library(png)
library(mclust)
library(multicore)
library(kernlab)
library(caret)
library(smPredict)
?train
biocLite("rJava")
library(smPredict)
version
library()
vignette("adegenet-basics")
vignette("adegenet-genomics")
x <- c(1,2,3,NA)
mean(x)
mean(x, na.rm=TRUE)
length(x)
is.na(x)
which(is.na(x))
length(which(!is.na(x))
)
library(matie)
x <- rnorm(n=1000, 0, 1)
y <- x
plot(x,y)
ma(x,y)
ma(data.frame(x,y))
y <- rnorm(n=1000, 0, 1)
plot(x,y)
ma(data.frame(x,y))
y <- x + rnorm(n=1000, 0, 1)
plot(x,y)
ma(data.frame(x,y))
ma(data.frame(x,y))
ma(data.frame(x,y))
x <- rnorm(n=100000, 0, 1)
y <- rnorm(n=100000, 0, 1)
ma(data.frame(x,y))
library(errorestimatoR)
dat.csv <- read.csv("http://www.ats.ucla.edu/stat/data/hsb2.csv")
d <- dat.csv
order(d$id, d$female)
?order
v <- c(3,2,4,6,7)
order <- order(v)
order
v[order]
fact <- c("a","a","b","b","b")
v
fact
tapply(X=v,INDEX=fact,FUN=mean)
library(camb)
library(ggplot2)
library(doMC)
setwd("~/Dropbox/projects/camb/examples/LogS/Reference_2")
StandardiseMolecules(structures.file="solubility_2007_ref2.sdf",
standardised.file="standardised.sdf",
removed.file="removed.sdf",
output = "output.csv",
remove.inorganic=TRUE,
fluorine.limit=3,
chlorine.limit=3,
bromine.limit=3,
iodine.limit=3,
min.mass.limit=20,
max.mass.limit=900)
StandardiseMolecules(structures.file="solubility_2007_ref2.sdf",
standardised.file="standardised.sdf",
removed.file="removed.sdf",
output = "output.csv",
remove.inorganic=TRUE,
fluorine.limit=3,
chlorine.limit=3,
bromine.limit=3,
iodine.limit=3,
min.mass.limit=20,
max.mass.limit=900)
