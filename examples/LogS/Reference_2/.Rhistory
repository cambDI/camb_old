model <- readRDS("svmRadial.rds")
model
estimator = BuildCaretErrorEstimator(ss$x.train, model, Nmax=20, cores=1)
indexes <- which(apply(as.data.frame(model$pred[, names(model$bestTune)]),
1, function(x, y) {
identical(as.numeric(x), as.numeric(y))
}, model$bestTune))
best <- model$pred[indexes, ]
order <- order(best$rowIndex, decreasing = FALSE)
best <- best[order, ]
obs <- best$obs
preds <- best$pred
fold.strings <- unique(best$Resample)
folds <- list()
for (fold in 1:length(fold.strings)) {
folds[[fold]] <- which(best$Resample == fold.strings[fold])
}
BuildEstimator(ss$x.train, folds, obs, preds, 20, 1, CEC)
Nmax <- 20
cores <- 1
optFunc <- CEC
errors <- preds - obs
x <- ss$x.train
dms <- CreateDistanceMatricesMC(x, folds, cores)
m <- CreateEstimatorMatrixMC(Nmax, folds, dms, errors, obs,
preds, cores)
CreateEstimatorMatrixMC
m <- do.call(cbind, mclapply(1:Nmax, CombineErrorEstimates,
folds, dms, errors, obs, preds, mc.cores = cores))
mclapply(1:Nmax, CombineErrorEstimates,
folds, dms, errors, obs, preds, mc.cores = cores)
1:Nmax
CombineErrorEstimates
folds
dms
errors
obs
preds
mclapply(1:Nmax, CombineErrorEstimates, folds, dms, errors, obs, preds, mc.cores = cores)
CombineErrorEstimates
m <- CalculateErrorEstimates(folds, dms, errors, obs, preds, N, confine)
CreateEstimatorMatrixMC
m <- CalculateErrorEstimates(folds, dms, errors, obs, preds, N, confine)
N <- 1
m <- CalculateErrorEstimates(folds, dms, errors, obs, preds, N, confine)
dms
CalculateErrorEstimates
num.folds <- length(folds)
num.folds
estimates <- sapply(1:num.folds, DoFold, folds, dms, errors,
obs, preds, N, func)
estimates <- sapply(1:num.folds, DoFold, folds, dms, errors,
obs, preds, N, confine)
estimates <- sapply(1:num.folds, DoFold, folds, dms, errors, obs, preds, N, confuse)
estimates.vec <- do.call(c, estimates)
estimates
N <- 4
num.folds <- length(folds)
estimates <- sapply(1:num.folds, DoFold, folds, dms, errors, obs, preds, N, confuse)
estimates
fold.vec <- do.call(c, folds)
fold.vec
length(fold.vec)
estimates
estimates <- lapply(1:num.folds, DoFold, folds, dms, errors, obs, preds, N, func)
estimates <- lapply(1:num.folds, DoFold, folds, dms, errors, obs, preds, N, confuse)
estimates
estimates.vec <- do.call(c, estimates)
fold.vec <- do.call(c, folds)
match <- match(1:length(fold.vec), fold.vec)
estimates.vec[match]
CalculateErrorEstimates <- function(folds, dms, errors, obs, preds, N, func) {
num.folds <- length(folds)
estimates <- lapply(1:num.folds, DoFold, folds, dms, errors, obs, preds, N, func)
estimates.vec <- do.call(c, estimates)
fold.vec <- do.call(c, folds)
match <- match(1:length(fold.vec), fold.vec)
estimates.vec[match]
}
library("caret", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
library("errorestimatoR", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
rm(BuildCaretErrorEstimator)
rm(CalculateErrorEstimates)
detach("package:errorestimatoR", unload=TRUE)
library("errorestimatoR", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
estimator = BuildCaretErrorEstimator(ss$x.train, model, Nmax=20, cores=1)
estimator
sigmas <- PredictSigmas(x=ss$y.train, estimator)
PredictSigmas
x <- ss$y.train
dm <- CreateNewDistanceMatrix(estimator$x, x)
estimator$x
x
dm <- CreateNewDistanceMatrix(estimator$x, x)
dim(estimator$x)
dim(x)
x <- ss$x.test
sigmas <- PredictSigmas(x=ss$x.test, estimator)
x <- ss$x.test
dim(estimator$x)
dim(x)
ss$x.test
sigmas <- PredictSigmas(x=ss$x.holdout, estimator)
preds <- predict(model, newdata = x.holdout)
preds <- predict(model, newdata = ss$x.holdout)
preds
ss$x.holdout
model
preds <- predict(model, newdata = ss$x.holdout)
preds
predict(model, newdata = ss$x.holdout)
model <- readRDS("rf.rds")
preds <- predict(model, newdata = ss$x.holdout)
preds
estimator = BuildCaretErrorEstimator(ss$x.train, model, Nmax=20, cores=1)
sigmas <- PredictSigmas(x=ss$x.holdout, estimator)
preds <- predict(model, newdata = ss$x.holdout)
preds
errors <- preds - ss$y.holdout
plot(sigmas, errors)
sigmas
dim(sigmas)
length(sigmas)
sigpred <- sigma
sigpred <- sigmas
plot(sigpred$sigmas, errors)
CEC(sigpred$sigmas, abs(errors))
trainsig <- PredictSigmas(x=ss$x.train, estimator)
trainpreds <- predict(model, newdata = ss$x.train)
trainpreds
trainerrors <- trainpreds - ss$train.y
trainerrors
ss$train.y
trainerrors <- trainpreds - ss$y.train
trainerrors
plot(trainerrors, trainsig)
trainsig
plot(trainerrors, trainsig$sigmas)
CEC(abs(trainerrors, trainsig$sigmas)
CEC(abs(trainerrors), trainsig$sigmas)
CEC(abs(trainerrors), trainsig$sigmas)
CEC(abs(trainerrors), trainsig$sigma.matrix[,2])
trainsig$sigma.matrix[,2]
length(trainsig$sigma.matrix[,2])
length(abs(trainerrors))
trainsig$sigma.matrix[,2]
trainsig$sigma.matrix[,2]
method <- "gbm"
tune.grid <- expand.grid(.n.trees=c(500,1000), .interaction.depth=c(25), .shrinkage = c(0.04, 0.08, 0.16))
registerDoMC(cores=1)
library(doMC)
method <- "gbm"
model <- train(ss$x.train, ss$y.train, method, tuneGrid=tune.grid, trControl=ss$trControl)
RMSE_CV <- function(model, digits = 3) {
signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
}
model
model <- readRDS("svmRadial.rds")
holdout.predictions <- as.vector(predict(model, newdata = dataset$x.holdout))
dataset <- ss
holdout.predictions <- as.vector(predict(model, newdata = dataset$x.holdout))
holdout.predictions
model <- readRDS("rf.rds")
holdout.predictions <- as.vector(predict(model, newdata = dataset$x.holdout))
holdout.predictions
CorrelationPlot <- function (pred,obs,margin=NULL,main="",ylab="Observed",xlab="Predicted",
PointSize=4,ColMargin="blue",TextSize=15,TitleSize=15,
XAxisSize=15,YAxisSize=15,TitleAxesSize=15,tmar=1,bmar=1,
rmar=1,lmar=1,AngleLab=30,LegendPosition="right",PointColor="black",
PointShape=16,MarginWidth=1)
{
if (isnot.vector(obs) || isnot.vector(pred)){
stop("The input data must be two vectors")
} else if ( length(obs) != length(pred) ){
stop("Both vectors have to be of equal length")
} else if(isnot.null(margin)) {
Data <- data.frame(Observed=obs,Predicted=pred)
p <- ggplot(Data, aes(x=Observed, y=Predicted)) +
geom_point(size=PointSize,colour=PointColor,shape=PointShape) +
geom_abline(slope=1,intercept=margin/2,colour=ColMargin,size=MarginWidth) +
geom_abline(slope=1,intercept=-(margin/2),colour=ColMargin,size=MarginWidth) + theme_bw() +
ggtitle(main) + ylab(ylab) + xlab(xlab)+
ylim(c(min(c(obs,pred)), max(c(obs,pred)))) + xlim(c(min(c(obs,pred)), max(c(obs,pred)))) +
theme(text = element_text(size=TextSize),axis.text.x = element_text(size=XAxisSize,angle = AngleLab, hjust = 1),
axis.title.x=element_text(size=TitleAxesSize),axis.title.y=element_text(size=TitleAxesSize),
axis.text.y=element_text(size=YAxisSize),legend.position=LegendPosition,plot.title=element_text(size=TitleSize),
legend.key=element_blank(), plot.margin=unit(c(tmar,rmar,bmar,lmar),"cm"))
} else {
Data <- data.frame(Observed=obs,Predicted=pred)
p <- ggplot(Data, aes(x=Observed, y=Predicted)) + geom_point(size=PointSize,colour=PointColor,shape=PointShape) + theme_bw() +
ggtitle(main) + ylab(ylab) + xlab(xlab) +
ylim(c(min(c(obs,pred)), max(c(obs,pred)))) + xlim(c(min(c(obs,pred)), max(c(obs,pred)))) +
theme(text = element_text(size=TextSize),axis.text.x = element_text(size=XAxisSize,angle = AngleLab, hjust = 1),
axis.title.x=element_text(size=TitleAxesSize),axis.title.y=element_text(size=TitleAxesSize),
axis.text.y=element_text(size=YAxisSize),legend.position=LegendPosition,plot.title=element_text(size=TitleSize),
legend.key=element_blank(), plot.margin=unit(c(tmar,rmar,bmar,lmar),"cm"))
}
return(p)
}
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout)
#################################################################################
## Model Assessment and Results Visualization
#################################################################################
##############
ErrorBarplot <- function(Data,X,Y,err,colour=NULL,shape=NULL,fill=NULL,main="",ylab="",xlab="",
minn=NULL,maxx=NULL,TextSize=15,TitleSize=15,XAxisSize=15,YAxisSize=15,
TitleAxesSize=15,AngleLab=35,barcol="red",barSize=1,
barWidth=0.3, LegendName="Legend",ColLegend=1,
RowLegend=NULL,LegendPosition="right",
tmar=1,bmar=1,rmar=1,lmar=1,stat="identity"){
yerr_names <- names(Data)[c(Y,err)]
yerrbar <- aes_string(ymin = paste(yerr_names, collapse = '-'),
ymax = paste(yerr_names,collapse='+'))
p <- ggplot(Data, aes_string(x=names(Data)[X], y=names(Data)[Y],fill=fill,colour=colour,shape=shape)) + theme_bw() +
geom_bar(position="dodge",stat=stat)+
geom_errorbar(mapping=yerrbar,
position=position_dodge(0.9), width=barWidth,color=barcol,size=barSize)
return(p)
}
##############
plotGrid <- function(plots,NRows,NCols,HeightBlocks,MyLegend=NULL,LegendRight=NULL,filename=NULL,PDFheight=10,PDFwidth=10){
if(is.null(MyLegend) && length(HeightBlocks) != NRows){stop("The length of each column is given in HeightBlocks. Thus, the length of HeightBlocks should be equal to the number of columns")}
if(isnot.null(MyLegend) && length(HeightBlocks) != 2 && is.null(LegendRight)){stop("HeightBlocks defines the height of the plots and the legend. Therefore, its length has to be equal to 2")}
if(isnot.null(MyLegend) && isnot.null(LegendRight) && length(HeightBlocks) != NRows){stop("The length of each column is given in HeightBlocks. Thus, the length of HeightBlocks should be equal to the number of columns")}
if (is.null(filename)){
t <- c("grid.arrange(arrangeGrob(")
for (i in 1:length(plots)){
t <- paste(t,plots[i]," + theme(legend.position='none'),",sep="")
}
if (isnot.null(MyLegend)){
if (length(HeightBlocks)>1){
jj <-  c(paste0(HeightBlocks[1:length(HeightBlocks)-1],","),HeightBlocks[length(HeightBlocks)])
} else {
jj <- HeightBlocks[1]
}
jj <- paste(jj,collapse=" ")
t <- paste(t,"nrow= ",NRows ,", ncol= ",NCols,"),arrangeGrob(MyLegend,nrow=1),heights=c(",jj,"))" )
} else {
if (length(HeightBlocks)>1){
jj <-  c(paste0(HeightBlocks[1:length(HeightBlocks)-1],","),HeightBlocks[length(HeightBlocks)])
} else {
jj <- HeightBlocks[1]
}
jj <- paste(jj,collapse=" ")
t <- paste(t,"nrow= ",NRows ,", ncol= ",NCols ,", heights=c(",jj,")))" )
}
if(isnot.null(LegendRight)){
substr(t,nchar(t),nchar(t)) = ""
t <- paste(t,",ncol=2)")
}
return(eval(parse(text=t)))
} else {
t <- c("grid.arrange(arrangeGrob(")
for (i in 1:length(plots)){
t <- paste(t,plots[i]," + theme(legend.position='none'),",sep="")
}
if (isnot.null(MyLegend)){
if (length(HeightBlocks)>1){
jj <-  c(paste0(HeightBlocks[1:length(HeightBlocks)-1],","),HeightBlocks[length(HeightBlocks)])
} else {
jj <- HeightBlocks[1]
}
jj <- paste(jj,collapse=" ")
t <- paste(t,"nrow= ",NRows ,", ncol= ",NCols,"),arrangeGrob(MyLegend,nrow=1),heights=c(",jj,"))" )
} else {
if (length(HeightBlocks)>1){
jj <-  c(paste0(HeightBlocks[1:length(HeightBlocks)-1],","),HeightBlocks[length(HeightBlocks)])
} else {
jj <- HeightBlocks[1]
}
jj <- paste(jj,collapse=" ")
t <- paste(t,"nrow= ",NRows ,", ncol= ",NCols ,", heights=c(",jj,")))" )
}
if(isnot.null(LegendRight)){
substr(t,nchar(t),nchar(t)) = ""
t <- paste(t,",ncol=2)")
}
pdfname <- paste(filename,".pdf",sep="")
pdf(file=pdfname,width=PDFwidth,height=PDFheight)
eval(parse(text=t))
dev.off()
return(1)
}
}
##############
## Observed vs predicted
CorrelationPlot <- function (pred,obs,margin=NULL,main="",ylab="Observed",xlab="Predicted",
PointSize=4,ColMargin="blue",TextSize=15,TitleSize=15,
XAxisSize=15,YAxisSize=15,TitleAxesSize=15,tmar=1,bmar=1,
rmar=1,lmar=1,AngleLab=30,LegendPosition="right",PointColor="black",
PointShape=16,MarginWidth=1)
{
if (isnot.vector(obs) || isnot.vector(pred)){
stop("The input data must be two vectors")
} else if ( length(obs) != length(pred) ){
stop("Both vectors have to be of equal length")
} else if(isnot.null(margin)) {
Data <- data.frame(Observed=obs,Predicted=pred)
p <- ggplot(Data, aes(x=Observed, y=Predicted)) +
geom_point(size=PointSize,colour=PointColor,shape=PointShape) +
geom_abline(slope=1,intercept=margin/2,colour=ColMargin,size=MarginWidth) +
geom_abline(slope=1,intercept=-(margin/2),colour=ColMargin,size=MarginWidth) + theme_bw() +
ggtitle(main) + ylab(ylab) + xlab(xlab)+
ylim(c(min(c(obs,pred)), max(c(obs,pred)))) + xlim(c(min(c(obs,pred)), max(c(obs,pred)))) +
theme(text = element_text(size=TextSize),axis.text.x = element_text(size=XAxisSize,angle = AngleLab, hjust = 1),
axis.title.x=element_text(size=TitleAxesSize),axis.title.y=element_text(size=TitleAxesSize),
axis.text.y=element_text(size=YAxisSize),legend.position=LegendPosition,plot.title=element_text(size=TitleSize),
legend.key=element_blank(), plot.margin=unit(c(tmar,rmar,bmar,lmar),"cm"))
} else {
Data <- data.frame(Observed=obs,Predicted=pred)
p <- ggplot(Data, aes(x=Observed, y=Predicted)) + geom_point(size=PointSize,colour=PointColor,shape=PointShape) + theme_bw() +
ggtitle(main) + ylab(ylab) + xlab(xlab) +
ylim(c(min(c(obs,pred)), max(c(obs,pred)))) + xlim(c(min(c(obs,pred)), max(c(obs,pred)))) +
theme(text = element_text(size=TextSize),axis.text.x = element_text(size=XAxisSize,angle = AngleLab, hjust = 1),
axis.title.x=element_text(size=TitleAxesSize),axis.title.y=element_text(size=TitleAxesSize),
axis.text.y=element_text(size=YAxisSize),legend.position=LegendPosition,plot.title=element_text(size=TitleSize),
legend.key=element_blank(), plot.margin=unit(c(tmar,rmar,bmar,lmar),"cm"))
}
return(p)
}
# Functions to evaluate models performance
# Tropsha, A.; Golbraikh, A. Predictive Quantitative Structureâ€“Activity Relationships Modeling:
#Development and Validation of QSAR Models. In: Handbook of Chemoinformatics Algorithms
#(Faulon, J.-L.; Bender, A., Eds.), Chapter 7, pp. 213-233, Chapman & Hall / CRC, London, UK, 2010.
# calculates the RMSE between two vectors
RMSE <- function(v1, v2) {
i1 <- which(!is.na(v1))
i2 <- which(!is.na(v2))
is <- intersect(i1, i2)
v1 <- v1[is]
v2 <- v2[is]
residuals <- abs(v1-v2)
return(as.numeric(sqrt( (residuals%*%residuals)/length(v1) )))
}
RMSE_CV <- function(model, digits = 3) {
signif(min(as.vector(na.omit(model$results$RMSE))), digits=3)
}
# calculates the MAE between two vectors
MAE <- function (v1, v2) {
i1 <- which(!is.na(v1))
i2 <- which(!is.na(v2))
is <- intersect(i1, i2)
v1 <- v1[is]
v2 <- v2[is]
residuals <- abs(v1 - v2)
return(sum(residuals)/length(v1))
}
# Calculates the slope between two vector (k')
slope <- function(v1,v2){ # v1=z.test v2=y.test
return(sum(v2*v1)/sum(v1*v1))
}
# Calculates the regression coefficient through the origin
Rsquared0 <- function(v1,v2) { #v1=z.test (y), v2=y.test (x)
if (is.vector(v1) && is.vector(v2) && length(v1)==length(v2)){
y_obs_mean <- mean(v2)
yr0 = v1 * slope(v1,v2)
first_term = (v2 - yr0)*(v2 - yr0)
second_term= (v2-y_obs_mean)*(v2-y_obs_mean)
return(1-(sum(first_term)/sum(second_term)))
}
else {print("Wrong input: input arguments are not vector or have unequal length")}
}
# Calculates the regression coefficient
Rsquared <- function(v1,v2) { # v1=z.test (y), v2=y.test (x)
if (is.vector(v1) && is.vector(v2) && length(v1)==length(v2)){
y_obs_mean <- mean(v2)
y_pred_mean <- mean(v1)
first_term <- sum((v2-y_obs_mean) * (v1 - y_pred_mean))
second_term <- sqrt(sum((v2-y_obs_mean)*(v2-y_obs_mean)) * sum((v1 - y_pred_mean)*(v1 - y_pred_mean)))
division <- first_term / second_term
return(division * division)
}
else {print("Wrong input: input arguments are not vector or have unequal length")}
}
# Calculates the Q squared
#Qsquared (z.test,y.test) (predicted vs observed)
Qsquared <- function(v1, v2) {
if (is.vector(v1) && is.vector(v2) && length(v1)==length(v2)){
y_obs_mean <- mean(v2)
first_term <- abs(v1-v2)*abs(v1-v2)
second_term <- abs(v2-y_obs_mean)*abs(v2-y_obs_mean)
return(1-(sum(first_term)/sum(second_term)))
}
else {print("Wrong input: input arguments are not vector or have unequal length")}
}
##############
## Validation of models
Validation <- function(pred,obs){
if (is.vector(pred) && is.vector(obs) && length(pred)==length(obs)){
metrics <- list(R2 = Rsquared(pred,obs), R02 = Rsquared0(pred,obs), Q2 = Qsquared(pred,obs), RMSE = RMSE(pred,obs), Slope=slope(pred,obs), MAE = MAE(pred, obs))
} else {
stop("Wrong input: input arguments are not vector or have unequal length")
}
return(metrics)
}
################################
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout)
library("camb", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout)
library(ggplot2)
library(doMC)
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout)
model
length(dataset$y.holdout)
length(dataset$y.train)
model
holdout.predictions <- as.vector(predict(model, newdata = dataset$x.holdout))
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout)
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout)
RMSE_CV(model)
tune.grid <- expand.grid(.sigma = expGrid(ini=-8, end=4, stride=2, base=2), .C = c(0.0001, 0.001, 0.01, 0.1, 1, 10, 100))
expGrid <- function(power.from, power.to, power.by, base){
grid <- c()
for (i in seq(power.from, power.to, power.by)){
grid <- append(grid,base^i)
}
return(grid)
}
tune.grid <- expand.grid(.sigma = expGrid(-8, 4, 2, 2), .C = c(0.0001, 0.001, 0.01, 0.1, 1, 10, 100))
tune.grid
saveRDS(dataset, file="dataset.rds")
dataset <- readRDS("dataset.rds")
model <- readRDS("rf.rds")
setwd("~/Dropbox/projects/camb/examples/LogS/Reference_1")
setwd("~/Dropbox/projects/camb/examples/LogS/Reference_2")
model <- readRDS("svmRadial.rds")
model
Rsquared_CV <- function(model, digits = 3) {
model$results$Rsquared[which(model$results$RMSE %in% min(model$results$RMSE, na.rm=TRUE))]
}
RMSE_CV(model)
Rsquared_CV(model)
holdout.predictions <- as.vector(predict(model, newdata = dataset$x.holdout))
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout)
holdout.predictions
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout, margin=1)
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout, margin=2)
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout, margin=1)
metrics <- Validation(holdout.predictions, dataset$y.holdout)
metrics
model <- readRDS("svmRadial.rds")
library(errorestimatoR)
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout)
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout, margin=1, main="LogS Observered vs Predicted", PointSize=0.2, ColMargin="red")
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout, margin=1, main="LogS Observered vs Predicted", PointSize=0.5, ColMargin="red")
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout, margin=1, main="LogS Observered vs Predicted", PointSize=2, ColMargin="red")
CorrelationPlot(pred=holdout.predictions, obs=dataset$y.holdout, margin=1, main="LogS Observered vs Predicted", PointSize=3, ColMargin="red")
p <- DensityResponse(targets$target)
p + labs(title="LogS target value distribution")
PreProcess
?preProcess
PreProcess
preProcess(ss$x.train, method=c("center", "scale", "blob"))
preProcess
preProcess.default
?preProcess
sigpred <- PredictSigmas(x=ss$x.holdout, estimator)
model
preds <- predict(model, newdata = ss$x.holdout)
errors <- preds - ss$y.holdout
plot(sigpred$sigmas, errors)
CEC(sigpred$sigmas, abs(errors))
sigpred$sigma.matrix[,2]
CEC(sigpred$sigma.matrix[,2], abs(errors))
CEC(sigpred$sigma.matrix[,1], abs(errors))
CEC(sigpred$sigma.matrix[,2], abs(errors))
plot(sigpred$sigmas, errors)
plot(errors, sigpred$sigmas)
plot(errors, sigpred$sigma.matrix[,2])
plot(errors, sigpred$sigma.matrix[,2])
plot(errors, sigpred$sigmas)
plot(errors, sigpred$sigma.matrix[,2])
plot(errors, sigpred$sigmas)
rbf
rbfdot
model
k <- rbfdot(sigma=0.00391)
k(x=1, y=1)
k(x=2, y=1)
k(x=0, y=1)
k(x=0, y=2)
k(x=0, y=3)
k(x=0, y=100)
k(x=0, y=10)
k(0,1)
k(1,2)
k(1)
k(2)
k(3)
library("errorestimatoR", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
library(errorestimatoR)
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
model <- readRDS("svmRadial.rds")
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
library(errorestimatoR)
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
matrix(rnorm(20), 4, 5)
m <- matrix(rnorm(20), 4, 5)
v <- rnorm(5)
k <- rbfdot(sigma=0.00391)
k <- rbfdot(sigma=0.00391)
library(kernlab)
k <- rbfdot(sigma=0.00391)
apply(m, 1, k, v)
m
1- apply(m, 1, k, v)
apply(m, 1, k, v)
1 - apply(m, 1, k, v)
model <- readRDS("svmRadial.rds")
library(errorestimatoR)
estimator = BuildCaretErrorEstimator(dataset$x.train, model, Nmax=20, cores=1)
